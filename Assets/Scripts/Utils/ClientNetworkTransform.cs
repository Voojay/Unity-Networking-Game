using System.Collections;
using System.Collections.Generic;
using Unity.Netcode.Components;
using UnityEngine;

public class ClientNetworkTransform : NetworkTransform // inherit from Networktransform 
{
    // by default, the network transform component on our turret is trusting the server (only the server updates the transform), meaning that the clients don't get to change the transform
    // This is usually what we do, HOWEVER, since it is trusting the server, that means that when we press our keyboard to move, it will send the movement to the server -> server validates if u can move or not -> sends that back to client to enact the server's consensus -> ensures security
    // But obviously, if we trust the server -> there will be latency (ping) (Ex: 20 ms = 10 (to server)+10 (back to client)) -> this can make moving no smooth
    // So, for now, we will just focus on trusting the client where if you move, it wont need the server's approval to move (no need to wait for server)
    // Movement is immediate and smooth but it is UNSAFE (clients can cheat)
    // This script is for Client Authorative (meaning that we trust the client)

    // For the client: if the client owns this object then we can actually update it
    // For networkBehaviours, we don't do Start() because for networks, there is a delay. So, we override OnNetworkSpawn instead.
    public override void OnNetworkSpawn() // this method is autogenerated by typing override OnNetworkSpawn
    {
        base.OnNetworkSpawn(); // leave this as it is

        // when we spawn these objects -> we assign ownership to whoever they belong to 
        // IsOwner is a bool
        // So in this case if this object is our player, then CanCommitToTransform = true -> we can change/update the transform
        // CanCommitToTransform is a public bool in the NetworkTransform Class
        CanCommitToTransform = IsOwner;
    }

    protected override void Update()
    {
        CanCommitToTransform = IsOwner; // to check if it's still true in each frame to see that no matter what, we are still the owner 
        base.Update();

        // Safety Checks: 1) If the networkmanager exists 2) Are we connected as a client 3) Are we listening to the server for connections
        if (NetworkManager != null) // No need to NetworkManager.Singleton since we are inheriting from NetworkTransform which inherits from NetworkBehaviour -> Which has a NetworkManager reference as a variable.
        {
            if (NetworkManager.IsConnectedClient || NetworkManager.IsListening) // if all the three checks are true
            {
                if (CanCommitToTransform)  
                {
                    // Parameters: The transform we want to commit (which is this object) AND time:  how long it was the last time we tried to sync the time -> to ensure it runs smoothly
                    TryCommitTransformToServer(this.transform, NetworkManager.LocalTime.Time); // Tells ther server: Syncs an object's movement/state from a client to the server 
                }
            }
        }
    }
    // for the server -> tells ther server to give up authority
    protected override bool OnIsServerAuthoritative() // this method is autogenerated by typing override OnIsServerAuthoritative
    {
        return false; // server is now not authorative -> the client is
    }
    
}
